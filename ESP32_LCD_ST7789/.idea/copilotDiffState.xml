<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/PC_DateReceive/uart_receive.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PC_DateReceive/uart_receive.cpp" />
              <option name="originalContent" value="//&#10;// Created by Rikka on 2025/8/4.&#10;//&#10;&#10;#include &quot;uart_receive.h&quot;&#10;&#10;// #include &quot;gui_guider.h&quot;&#10;&#10;ESP32Receiver::ESP32Receiver(HardwareSerial &amp;serialPort) : serial(serialPort) {}&#10;&#10;void ESP32Receiver::begin(unsigned long baudRate) {&#10;    serial.begin(baudRate);&#10;    while (!serial) {&#10;        ; // 等待串口初始化完成&#10;    }&#10;}&#10;&#10;void ESP32Receiver::update() {&#10;    while (serial.available()) {&#10;        char ch = serial.read();&#10;        buffer += ch;&#10;        // 若检测到数据包结束标志 '}'，退出读取&#10;        if (ch == '}') break;&#10;    }&#10;}&#10; &#10;// extern lv_ui tft_ui;&#10;bool ESP32Receiver::tryParseStats(SystemStats &amp;stats) {&#10;    // 检查是否存在完整的 JSON 数据包&#10;    int endIndex = buffer.indexOf('}');&#10;    if (endIndex == -1) return false;&#10;&#10;    // 提取完整 JSON 数据包&#10;    String jsonData = buffer.substring(0, endIndex + 1);&#10;    // 从缓冲区删除已解析部分&#10;    buffer = buffer.substring(endIndex + 1);&#10;&#10;    StaticJsonDocument&lt;200&gt; doc;&#10;    DeserializationError err = deserializeJson(doc, jsonData);&#10;    // lv_label_set_text(tft_ui.screen_label_log, jsonData.c_str()); // 显示原始数据&#10;    if (err) {&#10;        return false;&#10;    }&#10;    stats.cpu = doc[&quot;cpu&quot;].as&lt;float&gt;();&#10;    stats.gpu = doc[&quot;gpu&quot;].as&lt;float&gt;();&#10;    stats.ram = doc[&quot;ram&quot;].as&lt;float&gt;();&#10;    stats.fan = doc[&quot;fan&quot;].as&lt;float&gt;();&#10;    return true;&#10;}" />
              <option name="updatedContent" value="//&#10;// Created by Rikka on 2025/8/4.&#10;//&#10;&#10;#include &quot;uart_receive.h&quot;&#10;&#10;// #include &quot;gui_guider.h&quot;&#10;&#10;ESP32Receiver::ESP32Receiver(HardwareSerial &amp;serialPort) : serial(serialPort) {}&#10;&#10;void ESP32Receiver::begin(unsigned long baudRate) {&#10;    serial.begin(baudRate);&#10;    while (!serial) {&#10;        ; // 等待串口初始化完成&#10;    }&#10;}&#10;&#10;void ESP32Receiver::update() {&#10;    while (serial.available()) {&#10;        char ch = serial.read();&#10;        buffer += ch;&#10;        // 若检测到数据包结束标志 '}'，退出读取&#10;        if (ch == '}') break;&#10;    }&#10;}&#10; &#10;// extern lv_ui tft_ui;&#10;bool ESP32Receiver::tryParseStats(SystemStats &amp;stats) {&#10;    // 检查是否存在完整的 JSON 数据包&#10;    int endIndex = buffer.indexOf('}');&#10;    if (endIndex == -1) return false;&#10;&#10;    // 提取完整 JSON 数据包&#10;    String jsonData = buffer.substring(0, endIndex + 1);&#10;    // 从缓冲区删除已解析部分&#10;    buffer = buffer.substring(endIndex + 1);&#10;&#10;    StaticJsonDocument&lt;200&gt; doc;&#10;    DeserializationError err = deserializeJson(doc, jsonData);&#10;    // lv_label_set_text(tft_ui.screen_label_log, jsonData.c_str()); // 显示原始数据&#10;    if (err) {&#10;        return false;&#10;    }&#10;    stats.cpu = doc[&quot;cpu&quot;].as&lt;float&gt;();&#10;    stats.gpu = doc[&quot;gpu&quot;].as&lt;float&gt;();&#10;    stats.ram = doc[&quot;ram&quot;].as&lt;float&gt;();&#10;    stats.fan = doc[&quot;fan&quot;].as&lt;float&gt;();&#10;    return true;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/key/key.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/key/key.cpp" />
              <option name="originalContent" value="#include &quot;key.h&quot;&#10;#include &lt;gui_guider.h&gt;&#10;&#10;// 按键读取回调函数（需根据你的硬件实现）&#10;void my_keypad_read(lv_indev_t * indev, lv_indev_data_t * data)&#10;{&#10;    // 这里举例：假设GPIO检测到按键被按下&#10;    if (/* 检测到按键被按下 */) {&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;        data-&gt;key = LV_KEY_ENTER; // 可用LV_KEY_NEXT、LV_KEY_PREV等&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;void keypad_init(void)&#10;{&#10;    lv_indev_t * indev = lv_indev_create(); // 创建一个输入设备&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_KEYPAD); // 设置为键盘类型&#10;    lv_indev_set_read_cb(indev, my_keypad_read);    // 设置读取回调函数&#10;    // 如有需要，可设置 user_data、display 等&#10;}&#10;&#10;void key_value_update(void)&#10;{&#10;    if (g_key_pressed) {&#10;        g_key_pressed = false; // 重置按键状态&#10;        lv_indev_data_t data;&#10;        data.state = LV_INDEV_STATE_PRESSED;&#10;        data.key = g_last_key; // 使用全局变量获取最后按下的键&#10;        lv_indev_send_event(lv_indev_get_active_obj(), &amp;data); // 发送事件到LVGL&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &lt;Arduino.h&gt;&#10;#include &quot;key.h&quot;&#10;#include &lt;gui_guider.h&gt;&#10;&#10;volatile uint32_t g_last_key = 0;&#10;volatile bool g_key_pressed = false;&#10;&#10;// 按键读取回调函数（需根据你的硬件实现）&#10;void my_keypad_read(lv_indev_t * indev, lv_indev_data_t * data)&#10;{&#10;    if (g_key_pressed) {&#10;        data-&gt;state = LV_INDEV_STATE_PRESSED;&#10;        data-&gt;key = g_last_key;&#10;        g_key_pressed = false; // 只触发一次&#10;    } else {&#10;        data-&gt;state = LV_INDEV_STATE_RELEASED;&#10;    }&#10;}&#10;&#10;void keypad_init(void)&#10;{&#10;    lv_indev_t * indev = lv_indev_create(); // 创建一个输入设备&#10;    lv_indev_set_type(indev, LV_INDEV_TYPE_KEYPAD); // 设置为键盘类型&#10;    lv_indev_set_read_cb(indev, my_keypad_read);    // 设置读取回调函数&#10;    // 如有需要，可设置 user_data、display 等&#10;}&#10;&#10;void key_value_update(void)&#10;{&#10;    if (g_key_pressed) {&#10;        g_key_pressed = false; // 重置按键状态&#10;        lv_indev_data_t data;&#10;        data.state = LV_INDEV_STATE_PRESSED;&#10;        data.key = g_last_key; // 使用全局变量获取最后按下的键&#10;        lv_indev_send_event(lv_indev_get_active_obj(), &amp;data); // 发送事件到LVGL&#10;    }&#10;}&#10;&#10;// 串口接收并解析按键信息（在loop中调用）&#10;void key_serial_receive(HardwareSerial &amp;serial) {&#10;    while (serial.available()) {&#10;        char ch = serial.read();&#10;        if (ch == 'K') {&#10;            String keyStr = &quot;K&quot;;&#10;            for (int i = 0; i &lt; 15 &amp;&amp; serial.available(); ++i) {&#10;                char nextCh = serial.read();&#10;                if (nextCh == ' ' || nextCh == '\n' || nextCh == '\r') break;&#10;                keyStr += nextCh;&#10;            }&#10;            if (keyStr == &quot;Key.enter&quot;) {&#10;                g_last_key = LV_KEY_ENTER;&#10;                g_key_pressed = true;&#10;            } else if (keyStr == &quot;Key.left&quot;) {&#10;                g_last_key = LV_KEY_LEFT;&#10;                g_key_pressed = true;&#10;            } else if (keyStr == &quot;Key.right&quot;) {&#10;                g_last_key = LV_KEY_RIGHT;&#10;                g_key_pressed = true;&#10;            } else if (keyStr == &quot;Key.up&quot;) {&#10;                g_last_key = LV_KEY_UP;&#10;                g_key_pressed = true;&#10;            } else if (keyStr == &quot;Key.down&quot;) {&#10;                g_last_key = LV_KEY_DOWN;&#10;                g_key_pressed = true;&#10;            } else if (keyStr == &quot;Key.esc&quot;) {&#10;                g_last_key = LV_KEY_ESC;&#10;                g_key_pressed = true;&#10;            }&#10;        } else {&#10;            g_last_key = (uint8_t)ch;&#10;            g_key_pressed = true;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/key/key.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/key/key.h" />
              <option name="originalContent" value="//&#10;// Created by Rikka on 2025/8/5.&#10;//&#10;&#10;#ifndef KEY_H&#10;#define KEY_H&#10;&#10;#endif //KEY_H&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Rikka on 2025/8/5.&#10;//&#10;&#10;#ifndef KEY_H&#10;#define KEY_H&#10;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;&#10;extern volatile uint32_t g_last_key;&#10;extern volatile bool g_key_pressed;&#10;&#10;void keypad_init(void);&#10;&#10;#endif //KEY_H" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>